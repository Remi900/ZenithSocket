--[[
    Roblox Game Explorer Client
    ---------------------------
    Uses Zenith WebSocket API to stream game instance data
    to an external game explorer.

    Place this script in ServerScriptService.
]]

--// Dependencies
local RunService = game:GetService("RunService")

--// Configuration
local SERVER_URL = "wss://16f9d5f7-a3ab-4a77-ab99-a6227ac6cb63-00-dkbfcd0h8xpr.janeway.replit.dev/ws"
local UPDATE_INTERVAL = 3 -- seconds

--// State
local ws: any = nil
local isConnected = false
local lastUpdate = 0

--==============================================================
-- JSON Utilities
--==============================================================

local function encodeValue(v)
	if type(v) == "string" then
		return '"' .. v:gsub('"', '\\"') .. '"' -- escape quotes
	elseif type(v) == "number" or type(v) == "boolean" then
		return tostring(v)
	else
		return '"' .. tostring(v) .. '"'
	end
end

local function encodeTable(tbl)
	local parts = {}
	for k, v in pairs(tbl) do
		table.insert(parts, encodeValue(k) .. ":" .. encodeValue(v))
	end
	return "{" .. table.concat(parts, ",") .. "}"
end

--==============================================================
-- Instance Data Collection
--==============================================================

local function createInstanceData(instance, parentPath)
	local path = parentPath and (parentPath .. "." .. instance.Name) or "game." .. instance.Name

	local properties = {
		Name = instance.Name,
		ClassName = instance.ClassName,
		Parent = instance.Parent and instance.Parent.Name or "nil",
	}

	-- Add type-specific properties
	if instance:IsA("BasePart") then
		properties.Position = tostring(instance.Position)
		properties.Size = tostring(instance.Size)
		properties.Material = tostring(instance.Material)
		properties.Color = tostring(instance.Color)
		properties.Anchored = instance.Anchored
		properties.CanCollide = instance.CanCollide
		properties.Transparency = instance.Transparency

	elseif instance:IsA("Model") then
		properties.PrimaryPart = instance.PrimaryPart and instance.PrimaryPart.Name or "nil"

	elseif instance:IsA("Camera") then
		properties.CameraType = tostring(instance.CameraType)
		properties.FieldOfView = instance.FieldOfView
		properties.Focus = tostring(instance.Focus)

	elseif instance:IsA("Terrain") then
		properties.ReadVoxels = "Available"
		properties.WaterColor = tostring(instance.WaterColor)
		properties.WaterTransparency = instance.WaterTransparency
	end

	return {
		id = "inst_" .. math.random(1000, 9999),
		name = instance.Name,
		className = instance.ClassName,
		path = path,
		parent = instance.Parent and instance.Parent.Name or "nil",
		properties = properties,
	}
end

local function collectChildren(parent, parentPath, instances, depth, maxDepth)
	if depth >= maxDepth then return end

	for _, child in ipairs(parent:GetChildren()) do
		local inst = createInstanceData(child, parentPath)
		table.insert(instances, inst)
		collectChildren(child, inst.path, instances, depth + 1, maxDepth)
	end
end

local function collectBasicGameData()
	local instances = {}

	-- Root
	table.insert(instances, {
		id = "game_root",
		name = "game",
		className = "DataModel",
		path = "game",
		parent = "nil",
		properties = {
			Name = "game",
			ClassName = "DataModel",
			JobId = game.JobId,
			PlaceId = game.PlaceId,
			GameId = game.GameId,
		},
	})

	-- Services
	local services = {
		"Workspace", "Players", "Lighting", "ReplicatedStorage",
		"ServerStorage", "StarterGui", "StarterPack", "StarterPlayer",
		"SoundService", "TweenService", "UserInputService",
		"RunService", "HttpService", "Teams", "Chat"
	}

	for _, serviceName in ipairs(services) do
		local ok, service = pcall(function()
			return game:GetService(serviceName)
		end)
		if ok and service then
			local serviceData = createInstanceData(service, "game")

			-- Service-specific properties
			if serviceName == "Workspace" then
				serviceData.properties.CurrentCamera = service.CurrentCamera and service.CurrentCamera.Name or "nil"
				serviceData.properties.Gravity = service.Gravity
				serviceData.properties.FallenPartsDestroyHeight = service.FallenPartsDestroyHeight

			elseif serviceName == "Lighting" then
				serviceData.properties.Brightness = service.Brightness
				serviceData.properties.TimeOfDay = service.TimeOfDay
				serviceData.properties.Ambient = tostring(service.Ambient)

			elseif serviceName == "Players" then
				serviceData.properties.MaxPlayers = service.MaxPlayers
				serviceData.properties.NumPlayers = service.NumPlayers
			end

			table.insert(instances, serviceData)
			collectChildren(service, "game." .. serviceName, instances, 1, 4)
		end
	end

	return instances
end

--==============================================================
-- Networking
--==============================================================

local function sendGameData()
	if not isConnected or not ws then return end

	local instances = collectBasicGameData()

	-- Serialize
	local json = {}
	for _, inst in ipairs(instances) do
		local propsJson = encodeTable(inst.properties)
		table.insert(json, "{" ..
			'"id":' .. encodeValue(inst.id) .. "," ..
			'"name":' .. encodeValue(inst.name) .. "," ..
			'"className":' .. encodeValue(inst.className) .. "," ..
			'"path":' .. encodeValue(inst.path) .. "," ..
			'"parent":' .. encodeValue(inst.parent) .. "," ..
			'"properties":' .. propsJson .. "," ..
			'"children":[]}')
	end

	local message = '{"type":"gameTree","data":{"instances":[' .. table.concat(json, ",") .. "]}}"

	local ok, err = pcall(function()
		ws:Send(message)
	end)

	if ok then
		print("[GameExplorer] Sent " .. #instances .. " instances")
	else
		warn("[GameExplorer] Failed to send data:", err)
	end
end

local function connect()
	print("[GameExplorer] Connecting...")

	local ok, result = pcall(function()
		return WebSocket.New(SERVER_URL)
	end)

	if not ok then
		warn("[GameExplorer] Connection failed:", result)
		task.delay(3, connect) -- retry
		return
	end

	ws = result
	isConnected = true
	print("[GameExplorer] Connected!")

	ws.OnMessage:Connect(function(msg)
		print("[Server] " .. msg)
	end)

	ws.OnClose:Connect(function()
		print("[GameExplorer] Disconnected, retrying...")
		isConnected = false
		ws = nil
		task.delay(3, connect)
	end)

	sendGameData()
end

--==============================================================
-- Main
--==============================================================

print("[GameExplorer] Client starting...")
connect()

RunService.Heartbeat:Connect(function()
	if tick() - lastUpdate >= UPDATE_INTERVAL then
		sendGameData()
		lastUpdate = tick()
	end
end)
